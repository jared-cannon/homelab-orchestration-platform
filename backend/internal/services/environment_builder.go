package services

import (
	"fmt"
	"strings"

	"github.com/jared-cannon/homelab-orchestration-platform/internal/models"
)

// EnvironmentBuilder builds environment variable maps for docker-compose deployment
// Combines user config + generated secrets + database credentials
type EnvironmentBuilder struct {
	secretManager *SecretManager
	dbPoolManager *DatabasePoolManager
}

// NewEnvironmentBuilder creates a new environment builder
func NewEnvironmentBuilder(credService *CredentialService, dbPoolManager *DatabasePoolManager) *EnvironmentBuilder {
	return &EnvironmentBuilder{
		secretManager: NewSecretManager(credService),
		dbPoolManager: dbPoolManager,
	}
}

// BuildEnvironment creates a complete environment variable map for deployment
// Returns both a map (for programmatic use) and a .env file content (for docker-compose)
func (eb *EnvironmentBuilder) BuildEnvironment(
	deployment *models.Deployment,
	recipe *models.Recipe,
	userConfig map[string]interface{},
	device *models.Device,
	provisionedDB *models.ProvisionedDatabase,
) (map[string]string, string, error) {

	envMap := make(map[string]string)

	// 1. Add user-provided configuration (convert to uppercase env var names)
	for key, value := range userConfig {
		envMap[strings.ToUpper(key)] = fmt.Sprintf("%v", value)
	}

	// 2. Add deployment-specific variables
	envMap["DEPLOYMENT_ID"] = deployment.ID.String()
	envMap["COMPOSE_PROJECT"] = deployment.ComposeProject
	envMap["DEVICE_IP"] = device.IPAddress

	// 3. Generate or retrieve persistent secrets
	secrets, err := eb.secretManager.GenerateOrRetrieveSecrets(deployment.ID, recipe, userConfig)
	if err != nil {
		return nil, "", fmt.Errorf("failed to generate secrets: %w", err)
	}
	for key, value := range secrets {
		envMap[strings.ToUpper(key)] = value
	}

	// 4. Add database credentials if database was provisioned
	if provisionedDB != nil {
		dbEnvVars, err := eb.buildDatabaseEnvVars(provisionedDB, recipe.Database.EnvPrefix)
		if err != nil {
			return nil, "", fmt.Errorf("failed to build database env vars: %w", err)
		}
		for k, v := range dbEnvVars {
			envMap[k] = v
		}
	}

	// 5. Process password hashing (creates _HASH variants for password fields)
	if err := eb.secretManager.ProcessPasswordHashing(recipe, envMap); err != nil {
		return nil, "", fmt.Errorf("failed to hash passwords: %w", err)
	}

	// 6. Build .env file content
	envFileContent := eb.buildEnvFileContent(envMap)

	return envMap, envFileContent, nil
}

// buildDatabaseEnvVars creates environment variables for database connection
func (eb *EnvironmentBuilder) buildDatabaseEnvVars(provisionedDB *models.ProvisionedDatabase, envPrefix string) (map[string]string, error) {
	if envPrefix == "" {
		envPrefix = "DB_"
	}

	// Get database password from credential store
	password, err := eb.secretManager.credService.GetCredential(provisionedDB.CredentialKey)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve database password: %w", err)
	}

	envVars := provisionedDB.GetConnectionEnvVars(envPrefix)
	envVars[envPrefix+"PASSWORD"] = password

	// Also provide connection string
	envVars[envPrefix+"CONNECTION_STRING"] = buildConnectionString(provisionedDB, password)

	return envVars, nil
}

// buildConnectionString creates a database connection string
func buildConnectionString(db *models.ProvisionedDatabase, password string) string {
	if db.SharedDatabaseInstance == nil {
		return ""
	}

	switch db.SharedDatabaseInstance.Engine {
	case "postgres":
		return fmt.Sprintf("postgresql://%s:%s@%s:%d/%s",
			db.Username, password, db.Host, db.Port, db.DatabaseName)
	case "mysql", "mariadb":
		return fmt.Sprintf("mysql://%s:%s@%s:%d/%s",
			db.Username, password, db.Host, db.Port, db.DatabaseName)
	default:
		return ""
	}
}

// buildEnvFileContent creates the content for a .env file
func (eb *EnvironmentBuilder) buildEnvFileContent(envMap map[string]string) string {
	var builder strings.Builder
	builder.WriteString("# Auto-generated environment file\n")
	builder.WriteString("# Generated by Homelab Orchestration Platform\n\n")

	for key, value := range envMap {
		// Escape values that contain special characters
		escapedValue := escapeEnvValue(value)
		builder.WriteString(fmt.Sprintf("%s=%s\n", key, escapedValue))
	}

	return builder.String()
}

// escapeEnvValue escapes special characters in environment variable values
func escapeEnvValue(value string) string {
	// If value contains spaces, quotes, or special characters, wrap in quotes
	needsQuotes := strings.ContainsAny(value, " \t\n\"'$`\\#")

	if !needsQuotes {
		return value
	}

	// Escape existing quotes
	escaped := strings.ReplaceAll(value, "\"", "\\\"")
	return fmt.Sprintf("\"%s\"", escaped)
}
